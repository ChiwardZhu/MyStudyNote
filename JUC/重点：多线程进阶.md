## 1、什么是JUC？

JUC指的是java.util.concurrent包



## 2、线程、进程与程序（定义、相互之间的关系 ）

**程序：**==程序==只是一组指令的有序集合，它本身没有任何运行的含义，它只是一个==静态的实体==

**线程：**==线程==是进程的一个实体，是一个比进程更小的执行单位，是==CPU调度和分派的基本单位==。所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多。

**进程：**

* 进程是程序在某个数据集上的一次执行过程，因此==进程是一个动态的实体==，它有自己的生命周期。**进程和程序并不是一一对应的**，一个程序执行在不同的数据集上就成为不同的进程，可以用进程控制块来唯一地标识每个进程。进程是系统进行**资源分配和调度的一个独立单位。**
* 一个运行中的程序至少有一个进程,一个进程至少有一个线程。另外，进程在执行过程中拥有独立的内存单元，而线程共享其父进程的内存和系统资源。



Java默认有几个线程？   2个：**main线程与GC线程**

Java真的能开启线程？	**不能！**

### **进程的生命周期：**

![img](https://img-blog.csdn.net/20160406224034988?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

创建状态：系统已为其分配了PCB，但进程所需资源尚未分配，进程还未进入主存，即创建工作尚未完成，进程还不能被调度运行。

就绪状态：进程已分配到除CPU以外的所有必要资源，等待获得CPU。

执行状态：进程已获得CPU，程序正在执行。

阻塞状态：正在执行的进程由于某事件而暂时无法继续执行时，放弃处理机而自行阻塞。

终止状态：进程到达自然结束点或者因意外被终结，将进入终止状态，进入终止状态的进程不能再执行，但在操作系统中仍然保留着一个记录，其中保存状态码和一些计时统计数据，供其它进程收集。



### 线程的生命周期：

![Java线程状态变迁](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%20%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png)

![Java线程的状态](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png)

- 新建：就是刚使用new方法，new出来的线程；
- 就绪：就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行;
- 运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能;
- 阻塞：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态;
- 销毁：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源;

## 3、并行与并发

顾名思义，并发强调的是一起出发，并行强调的是一起执行。

并行：指在同一时刻，有多条指令在多个处理器上同时执行；（也可以理解为，在同一时刻两个或者多个事件在不同实体上发生）所以无论从微观还是从宏观来看，二者都是一起执行的。

![img](https://upload-images.jianshu.io/upload_images/7557373-72912ea8e89c4007.jpg)

并发：指在同一时刻只能有一条指令执行，但多个进程指令被快速的交替执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。

![img](https://upload-images.jianshu.io/upload_images/7557373-da64ffd6d1effaac.jpg)



并行在多核处理器系统中存在，而并发可以在单核处理器和多核处理器系统中都存在，并发能够在单核处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速交替执行）。

------

当有多个线程在操作时，如果系统只有一个 CPU，则它根本不可能真正同时进行一个以上的线程，它只能把 CPU 运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时,其它线程处于某个状态.这种方式我们称之为并发（Concurrent）。

当系统有一个以上 CPU 时，则线程的操作有可能非并发。当一个 CPU 执行一个线程时，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，可以同时进行，这种方式我们称之为并行（Parallel）。



> wait/sleep区别

1. **来自不同的类**
   * wait==》Object
   * sleep==》Thread
2. **关于锁的释放**
   * wait会释放锁
   * sleep不会释放锁
3. **使用的范围不同**
   * wait必须在同步代码块中
   * sleep在任何地方都可以



## Lock锁（重点）

> 传统的Synchronize





> Lock

![image-20200619161221924](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200619161221924.png)

![image-20200619161043372](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200619161043372.png)

公平锁：十分公平——先来后到

非公平锁：十分不公平——可以插队（默认）



> Synchronized和Lock区别

1. Synchronized是Java关键字；Lock是Java类
2. Synchronized无法判断获取锁的状态；Lock可以判断是否获取到锁
3. Synchronized会自动释放锁；Lock必须要手动释放锁，如果不释放锁，就会产生死锁
4. Synchronized线程1（获取锁，阻塞），线程2（等待）；Lock不一定会一直等待
5. Synchronized可重入锁，不可以中断，非公平；Lock可重入锁，可以判断锁状态，非公平（可以自己设置）
6. Synchronized适合锁少量的代码同步问题；Lock适合锁大量的同步问题





> Synchronized版         生产者消费者

```java
package com.zhu.demo;

public class ProCon {
    public static void main(String[] args) {
        Data data=new Data();

        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"A").start();

        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"B").start();
    }
}

class Data{
    private int number=0;

    public synchronized void increment() throws InterruptedException {
        if (number!=0){
            this.wait();
        }
        number++;
        System.out.println(Thread.currentThread().getName()+
                "==>"+number);
        this.notifyAll();
    }

    public synchronized void decrement() throws InterruptedException {
        if (number==0){
            this.wait();
        }
        number--;
        System.out.println(Thread.currentThread().getName()+
                "==>"+number);
        this.notifyAll();
    }
}
```

![image-20200619170906842](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200619170906842.png)

**为了防止虚假唤醒问题**==》将if改为while

```java
package com.zhu.demo;

public class ProCon {
    public static void main(String[] args) {
        Data data=new Data();

        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"A").start();

        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"B").start();

        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"C").start();

        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"D").start();
    }
}

class Data{
    private int number=0;

    public synchronized void increment() throws InterruptedException {
        while (number!=0){
            this.wait();
        }
        number++;
        System.out.println(Thread.currentThread().getName()+
                "==>"+number);
        this.notifyAll();
    }

    public synchronized void decrement() throws InterruptedException {
        while (number==0){
            this.wait();
        }
        number--;
        System.out.println(Thread.currentThread().getName()+
                "==>"+number);
        this.notifyAll();
    }
}
```



>  JUC版 	生产者消费者

```java
package com.zhu.demo;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ProConLock {
    public static void main(String[] args) {
        Data2 data=new Data2();

        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"A").start();

        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"B").start();

        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"C").start();

        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"D").start();
    }
}

class Data2{
    private int number=0;

    Lock lock=new ReentrantLock();
    Condition condition=lock.newCondition();

    public void increment() throws InterruptedException {
        try {
            lock.lock();
            while (number!=0){
                condition.await();
            }
            number++;
            System.out.println(Thread.currentThread().getName()+
                    "==>"+number);
            condition.signalAll();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }

    }

    public void decrement() throws InterruptedException {
        try {
            lock.lock();
            while (number==0){
                condition.await();
            }
            number--;
            System.out.println(Thread.currentThread().getName()+
                    "==>"+number);
            condition.signalAll();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
```



> Condition	精准唤醒==》有序执行

```java
package com.zhu.demo;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class LockCondition {
    public static void main(String[] args) {
        Data3 data=new Data3();
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                data.printA();
            }
        },"A").start();

        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                data.printB();
            }
        },"B").start();

        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                data.printC();
            }
        },"C").start();
    }
}

class Data3{

    private Lock lock=new ReentrantLock();
    private Condition condition1=lock.newCondition();
    private Condition condition2=lock.newCondition();
    private Condition condition3=lock.newCondition();
    private int number=1;
    public void printA(){
        lock.lock();
        try {
            while (number!=1){
                condition1.await();
            }
            System.out.println(Thread.currentThread().getName()+
                    "==>AAAAAA");
            number=2;
            condition2.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void printB(){
        lock.lock();
        try {
            while (number!=2){
                condition2.await();
            }
            System.out.println(Thread.currentThread().getName()+
                    "==>BBBBBBBB");
            number=3;
            condition3.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void printC(){
        lock.lock();
        try {
            while (number!=3){
                condition3.await();
            }
            System.out.println(Thread.currentThread().getName()+
                    "==>CCCCCCCC");
            number=1;
            condition1.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
```



> 什么是锁？如何判断锁的是谁？

每个对象只有一把锁

8锁问题总结：

1、new this 调用的这个对象，是一个具体的对象！

2、static class 唯一的一个模板！

在我们编写多线程程序得时候，只需要搞明白这个到底锁的是什么就不会出错了！

```java
synchronized(Demo.class){

}//等同于static synchronized 方法
synchronized(this){

}//等同于synchronized普通方法
```



## 集合类不安全

> List不安全

```java
package com.zhu.unsafelist;

import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

//java.util.ConcurrentModificationException并发修改异常
public class ListTest {
    //并发下ArrayList 不安全
    /*
    *   解决方案：
    * 1、用Vector
    * 2、Collections.synchronizedList
    * 3、CopyOnWriteArrayList
    *
    * CopyOnWriteArrayList  写入时复制  COW 计算机程序设计领域的一种优化策略
    * 多个线程调用的时候，List，读取的时候
    * 写入的时候避免覆盖，造成数据问题
    * */
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        List<String> list1 = new Vector<>();
        List<String> list2 = Collections.synchronizedList(new ArrayList<>());
        List<String> list3 = new CopyOnWriteArrayList<>();
        for (int i = 1; i <= 10; i++) {
            new Thread(()->{
                list.add(UUID.randomUUID().toString().substring(0,5));
                System.out.println(list);
            },String.valueOf(i)).start();
        }
    }
}
```



> set不安全

```java
package com.zhu.unsafelist;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.CopyOnWriteArraySet;

/*
* 解决方法：
* 1、Set<String> set = Collections.synchronizedSet(new HashSet<>());
* 2、Set<String> set = new CopyOnWriteArraySet<>();
 * */
public class SetList {
    public static void main(String[] args) {
//        Set<String> set = new HashSet<>();
//        Set<String> set = Collections.synchronizedSet(new HashSet<>());
        Set<String> set = new CopyOnWriteArraySet<>();
        for (int i = 1; i <= 20; i++) {
            new Thread(()->{
                set.add(UUID.randomUUID().toString().substring(0,5));
                System.out.println(set);
            },String.valueOf(i)).start();
        }
    }
}
```

hashSet底层是什么？

```java
public HashSet() {
        map = new HashMap<>();
}

//add set 本质就是map key是不能重复的
public boolean add(E e) {
        return map.put(e, PRESENT)==null;
}
private static final Object PRESENT = new Object();
```



> map不安全

```java
package com.zhu.unsafelist;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

/*
* 解决方法：
* 1、Map<String, String> map = Collections.synchronizedMap(new HashMap<>());
* 2、Map<String, String> map = new ConcurrentHashMap<>();
 * */
public class MapTest {
    public static void main(String[] args) {
//        Map<String, String> map = new HashMap<>();
//        Map<String, String> map = Collections.synchronizedMap(new HashMap<>());
        Map<String, String> map = new ConcurrentHashMap<>();

        for (int i = 1; i <= 30; i++) {
            new Thread(()->{
                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0,5));
                System.out.println(map);
            },String.valueOf(i)).start();
        }
    }
}
```



## Callable

![image-20200620001307095](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200620001307095.png)

1. 可以有返回值
2. 可以跑出异常
3. 方法不同，run()/call()

```java
package com.zhu.callable;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class CallableTest {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //new Thread(new Runnable()).start();
        //new Thread(new FutureTask<V>()).start();
        //new Thread(new FutureTask<V>(Callable)).start();

        MyThread myThread = new MyThread();
        FutureTask futureTask = new FutureTask(myThread);//适配类
        new Thread(futureTask,"A").start();
        System.out.println(futureTask.get());//获取callable的返回值
    }
}

class MyThread implements Callable<String>{

    @Override
    public String call() throws Exception {
        System.out.println("call()");
        return "????";
    }
}
```

**注意：**

1. 有缓存
2. 结果可能需要等待，可能会出现阻塞



## 8、常用的辅助类

### 8.1 CountDownLatch

![image-20200620013102133](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200620013102133.png)

```java
package com.zhu.add;

import java.util.concurrent.CountDownLatch;

public class CountDownLatchDemo {
    public static void main(String[] args) throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(6);

        for (int i = 1; i <= 6; i++) {
            new Thread(()->{
                System.out.println(Thread.currentThread().getName()+" Go Out");
                countDownLatch.countDown();//数字-1
            },String.valueOf(i)).start();
        }

        countDownLatch.await();//等待数字归零，再执行以下操作
        System.out.println("Close Door");
    }
}
```



### 8.2 CyclicBarrier

![image-20200620013955379](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200620013955379.png)

**加法计数器**

```java
package com.zhu.add;

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierDemo {
    public static void main(String[] args) {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> {
            System.out.println("成功召唤神龙");
        });

        for (int i = 1; i <= 7; i++) {
            final int tmp=i;
            new Thread(()->{
                System.out.println(Thread.currentThread().getName()+"收集"+tmp+"颗龙珠");
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```



### 8.3 Semaphore——信号量

![image-20200620015006454](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200620015006454.png)

```java
package com.zhu.add;

import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

public class SemaphoreDemo {
    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(3);

        for (int i = 1; i <= 6; i++) {
            new Thread(()->{
                try {
                    semaphore.acquire();//得到车位
                    System.out.println(Thread.currentThread().getName()+"抢到车位");
                    TimeUnit.SECONDS.sleep(2);
                    System.out.println(Thread.currentThread().getName()+"离开车位");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }finally {
                    semaphore.release();//释放
                }
            },String.valueOf(i)).start();
        }
    }
}
```

==semaphore.acquire()==获得，假设已经满了，就会等待，直到被释放为止；

==semaphore.release()==释放，会将当前的信号量释放+1，然后唤醒等待的线程

作用：多个共享资源互斥的使用，并发限流，控制最大的线程数



## 9、读写锁

#### ReadWriteLock

![image-20200620131754597](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200620131754597.png)

```java
package com.zhu.rw;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReadWriteLockDemo {
    public static void main(String[] args) {
        /*MyCache myCache = new MyCache();

        for (int i = 1; i <= 5; i++) {
            final int tmp=i;
            new Thread(()->{
                myCache.put(tmp+"",tmp+"");
            },String.valueOf(i)).start();
        }
        for (int i = 1; i <= 5; i++) {
            final int tmp=i;
            new Thread(()->{
                myCache.get(tmp+"");
            },String.valueOf(i)).start();
        }*/

        MyCacheLock myCacheLock = new MyCacheLock();

        for (int i = 1; i <= 5; i++) {
            final int tmp=i;
            new Thread(()->{
                myCacheLock.put(tmp+"",tmp+"");
            },String.valueOf(i)).start();
        }
        for (int i = 1; i <= 5; i++) {
            final int tmp=i;
            new Thread(()->{
                myCacheLock.get(tmp+"");
            },String.valueOf(i)).start();
        }
    }
}
//加锁的
class MyCacheLock{
    private volatile Map<String,Object> map=new HashMap<>();
    //读写锁
    private ReadWriteLock lock= new ReentrantReadWriteLock();
    //写，只有一个线程写
    public void put(String key,Object value){
        lock.writeLock().lock();
        try {
            System.out.println(Thread.currentThread().getName()+"写入"+key);
            map.put(key,value);
            System.out.println(Thread.currentThread().getName()+"写入OK");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.writeLock().unlock();
        }
    }
    //读，所有线程都可读
    public void get(String key){
        lock.readLock().lock();
        try {
            System.out.println(Thread.currentThread().getName()+"读取"+key);
            Object o = map.get(key);
            System.out.println(Thread.currentThread().getName()+"读取OK");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.readLock().unlock();
        }
    }
}

class MyCache{
    private volatile Map<String,Object> map=new HashMap<>();

    //写
    public void put(String key,Object value){
        System.out.println(Thread.currentThread().getName()+"写入"+key);
        map.put(key,value);
        System.out.println(Thread.currentThread().getName()+"写入OK");
    }
    //读
    public void get(String key){
        System.out.println(Thread.currentThread().getName()+"读取"+key);
        Object o = map.get(key);
        System.out.println(Thread.currentThread().getName()+"读取OK");
    }
}

```

总结：

1. 写锁（独占锁）；读锁（共享锁）；
2. 可以同时多个线程读，不可以多个线程同时读写或多个线程同时写



## 10、阻塞队列

![image-20200620135732250](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200620135732250.png)

**BlockingQueue**

![image-20200620141026426](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200620141026426.png)

| 方法           | 抛出异常  | 不抛异常但有返回值 | 阻塞等待 | 超时等待                                |
| -------------- | --------- | ------------------ | -------- | --------------------------------------- |
| 添加           | add()     | offer()            | put()    | offer(E e, long timeout, TimeUnit unit) |
| 移除           | remove()  | poll()             | take()   | poll(long timeout, TimeUnit unit)       |
| 判断是否为队首 | element() | peek()             | -        | -                                       |

```java
//抛出异常
public static void test1(){
    ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue<>(3);
    System.out.println(arrayBlockingQueue.add("a"));
    System.out.println(arrayBlockingQueue.add("b"));
    System.out.println(arrayBlockingQueue.add("c"));
    //IllegalStateException: Queue full 抛出队列已满异常
    //        System.out.println(arrayBlockingQueue.add("d"));
    System.out.println("================");
    System.out.println(arrayBlockingQueue.remove());
    System.out.println(arrayBlockingQueue.remove());
    System.out.println(arrayBlockingQueue.remove());
    //java.util.NoSuchElementException 抛出没元素异常
    //System.out.println(arrayBlockingQueue.remove());
}
```

```java
//不抛异常但有返回值
public static void test2(){
    ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue<>(3);
    System.out.println(arrayBlockingQueue.offer("a"));
    System.out.println(arrayBlockingQueue.offer("b"));
    System.out.println(arrayBlockingQueue.offer("c"));

    System.out.println(arrayBlockingQueue.offer("d"));//返回false
    System.out.println("================");
    System.out.println(arrayBlockingQueue.poll());
    System.out.println(arrayBlockingQueue.poll());
    System.out.println(arrayBlockingQueue.poll());

    System.out.println(arrayBlockingQueue.poll());//返回null
}

```

```java
//阻塞等待
public static void test3() throws InterruptedException {
    ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue<>(3);
    arrayBlockingQueue.put("a");
    arrayBlockingQueue.put("b");
    arrayBlockingQueue.put("c");

    arrayBlockingQueue.put("d");
    System.out.println("================");
    System.out.println(arrayBlockingQueue.take());
    System.out.println(arrayBlockingQueue.take());
    System.out.println(arrayBlockingQueue.take());

    System.out.println(arrayBlockingQueue.take());
}
```

```java
//超时等待
public static void test4() throws InterruptedException {
    ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue<>(3);
    System.out.println(arrayBlockingQueue.offer("a"));
    System.out.println(arrayBlockingQueue.offer("b"));
    System.out.println(arrayBlockingQueue.offer("c"));

    System.out.println(arrayBlockingQueue.offer("d",2, TimeUnit.SECONDS));//返回false
    System.out.println("================");
    System.out.println(arrayBlockingQueue.poll());
    System.out.println(arrayBlockingQueue.poll());
    System.out.println(arrayBlockingQueue.poll());

    System.out.println(arrayBlockingQueue.poll(2, TimeUnit.SECONDS));//返回null
}
```



> SynchronousQueue	同步队列
>
> 只能存一个元素，也就是存入一个就必须要取出那个，否则进入阻塞状态

```java
package com.zhu.bq;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.SynchronousQueue;

public class SynchronousQueueDemo {
    public static void main(String[] args) {
        BlockingQueue<String> synchronousQueue = new SynchronousQueue();

        new Thread(()->{
            try {
                System.out.println(Thread.currentThread().getName()+"put 1");
                synchronousQueue.put("1");
                System.out.println(Thread.currentThread().getName()+"put 2");
                synchronousQueue.put("2");
                System.out.println(Thread.currentThread().getName()+"put 3");
                synchronousQueue.put("3");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"T1").start();

        new Thread(()->{
            try {
                System.out.println(Thread.currentThread().getName()+"take 1");
                synchronousQueue.take();
                System.out.println(Thread.currentThread().getName()+"take 2");
                synchronousQueue.take();
                System.out.println(Thread.currentThread().getName()+"take 3");
                synchronousQueue.take();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"T2").start();
    }
}
```



## 线程池（重点：3大方法、7大参数、4种拒绝策略）

> 池化技术

池化技术：开始时已经有一些资源了，池中有则从池中取出来用，用完就放回池中

线程池的好处：

1. 降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；
2. 提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；
3. 方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换（cpu切换线程是有时间成本的（需要保持当前执行线程的现场，并恢复要执行线程的现场））。
4. 提供更强大的功能，延时定时线程池。



> 3大方法

![image-20200620150511688](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200620150511688.png)

```java
package com.zhu.threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ExecutorDemo {
    public static void main(String[] args) {
//        ExecutorService threadPool = Executors.newSingleThreadExecutor();//单个线程
//        ExecutorService threadPool = Executors.newFixedThreadPool(5);//固定线程的线程池
        ExecutorService threadPool = Executors.newCachedThreadPool();//可伸缩的线程池

        try {
            for (int i = 0; i < 100; i++) {
                threadPool.execute(()->{
                    System.out.println(Thread.currentThread().getName()+"ok");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            threadPool.shutdown();
        }
    }
}
```

> 7大参数

**源码：**

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}

public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());

}
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}

//本质是new ThreadPoolExecutor(7个参数)
public ThreadPoolExecutor(int corePoolSize,// 核心线程池大小
                          int maximumPoolSize,// 最大核心线程池大小
                          long keepAliveTime,// 超时时间，没有调用就会释放
                          TimeUnit unit,// 超时单位
                          BlockingQueue<Runnable> workQueue,// 阻塞队列
                          ThreadFactory threadFactory,// 线程工厂，创建线程的
                          RejectedExecutionHandler handler// 拒绝策略) {
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.acc = System.getSecurityManager() == null ?
        null :
    AccessController.getContext();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
```



![image-20200620154433619](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200620154433619.png)

> 用ThreadPoolExecutor创建线程池

```java
package com.zhu.threadpool;

import java.util.concurrent.*;

public class ThreadPoolExecutorDemo {
    public static void main(String[] args) {
        ExecutorService threadPool = new ThreadPoolExecutor(
                2,
                5,
                3,
                TimeUnit.SECONDS,
                new LinkedBlockingDeque<>(3),//只有当超出阻塞队列容量时，才会开启最大线程
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.AbortPolicy()//线程池中的线程都已被使用，并且阻塞队列已满，则会抛出异常
        );
        try {
            for (int i = 0; i < 9; i++) {
                threadPool.execute(()->{
                    System.out.println(Thread.currentThread().getName()+"ok");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            threadPool.shutdown();
        }
    }
}
```



> 4中拒绝策略

![image-20200620154743619](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200620154743619.png)

1. AbortPolicy：当线程池中的线程都已被使用，并且超出阻塞队列的容量，则会抛出异常
2. CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务
3. DiscardPolicy：丢弃任务，但是不抛出异常。
4. DiscardOldestPolicy：尝试丢弃队列最前面的任务，然后重新提交被拒绝的任务，不会抛出异常



> 小结与拓展

线程池的最大线程数到底如何定义？

* CPU 密集型：根据该电脑CPU的核数决定
* IO 密集型：>根据程序中最耗IO的线程的任务数



## 四大函数式接口

lambda表达式、链式编程、函数式接口、Stream流式计算

> 函数式接口：只有一个方法的接口

```java
@FunctionalInterface
public interface Runnable {
    public abstract void run();
}
//简化编程模型，在新版本的框架底层大量运用
//foreach(消费者类的函数式接口)
```

![image-20200620184137007](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200620184137007.png)



> Function函数型接口

![image-20200620191629441](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200620191629441.png)

```java
package com.zhu.function;

import java.util.function.Function;

public class FunctionDemo {
    public static void main(String[] args) {
        /*Function<String,String> function = new Function<String,String>(){
            @Override
            public String apply(String str) {
                return str;
            }
        };*/

        Function<String,String> function =(str)->{return str;};
        System.out.println(function.apply("aaa"));
    }
}

```



> 断定型接口

![image-20200620192344921](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200620192344921.png)

```java
package com.zhu.function;

import java.util.function.Predicate;

public class PredicateDemo {
    public static void main(String[] args) {
        /*Predicate<String> predicate = new Predicate<String>(){

            @Override
            public boolean test(String str) {
                return str.isEmpty();
            }
        };*/
        Predicate<String> predicate = (str)->{return str.isEmpty();};
        System.out.println(predicate.test("qqq"));
    }
}
```



> Consumer	消费者接口

![image-20200620202337386](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200620202337386.png)

```java
package com.zhu.function;

import java.util.function.Consumer;

public class ConsumerDemo {
    public static void main(String[] args) {
        /*Consumer<String> consumer= new Consumer<String>() {
            @Override
            public void accept(String str) {
                System.out.println(str);
            }
        };*/
        Consumer<String> consumer=(str)->{System.out.println(str);};
                consumer.accept("zzz");
    }
}
```



> Supplier	供应者接口

![image-20200620202812514](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200620202812514.png)

```java
package com.zhu.function;

import java.util.function.Supplier;

public class SupplierDemo {
    public static void main(String[] args) {
        /*Supplier<String> supplier=new Supplier<String>() {
            @Override
            public String get() {
                return "zzh";
            }
        };*/
        Supplier<String> supplier=()->{return "zzh";};
        System.out.println(supplier.get());
    }
}
```



## Stream流式计算

大数据=存储+计算

集合、MySQL本质就是存储东西的

计算都应该交给流来操作

![image-20200620203550111](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200620203550111.png)

```java
package com.zhu.stream;

import java.util.Arrays;
import java.util.List;

public class StreamDemo {
    public static void main(String[] args) {
        User u1 =new User(1,"a",21);
        User u2 =new User(2,"b",22);
        User u3 =new User(3,"c",23);
        User u4 =new User(4,"d",24);
        User u5 =new User(6,"e",25);
        List<User> users = Arrays.asList(u1, u2, u3, u4, u5);
        //链式编程+流计算
        users.stream()
            .filter(user -> {return user.getId()%2==0;})
            .filter(user -> {return user.getAge()>23;})
            .map(user -> {return user.getName().toUpperCase();})
            .sorted((uu1,uu2)->{return uu2.compareTo(uu1);})
            .limit(1)
            .forEach(System.out::println);
    }
}

```



## Forkjoin

> Forkjoin特点：工作窃取





![image-20200620215214483](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200620215214483.png)

```java
package com.zhu.forkjoin;


import java.util.concurrent.RecursiveTask;

public class ForkJoinDemo extends RecursiveTask<Long> {
    private Long start;
    private Long end;
    //临界值
    private Long temp=10000L;

    public ForkJoinDemo(Long start,Long end){
        this.start=start;
        this.end=end;
    }

    @Override
    protected Long compute() {
        if ((end-start)<temp){
            long sum=0L;
            for (long i = start; i <= end; i++) {
                sum+=i;
            }
            return sum;
        }else {//forkjoin递归
            long middle=(start+end)/2;
            ForkJoinDemo task1 = new ForkJoinDemo(start,middle);
            task1.fork();//拆分任务，把任务压入线程队列
            ForkJoinDemo task2 = new ForkJoinDemo(middle+1,end);
            task2.fork();
            return task1.join()+task2.join();
        }
    }
}
```



```java
//测试
package com.zhu.forkjoin;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.ForkJoinTask;
import java.util.stream.LongStream;

public class ForkJoinTest {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        test1();
        test2();
        test3();
    }

    public static void test1(){
        long sum=0L;
        long start=System.currentTimeMillis();
        for (long i = 1; i <= 10_0000_0000; i++) {
            sum+=i;
        }
        long end=System.currentTimeMillis();
        System.out.println("sum="+sum+" 求和时间="+(end-start));
    }

    public static void test2() throws ExecutionException, InterruptedException {
        long start=System.currentTimeMillis();
        ForkJoinPool forkJoinPool = new ForkJoinPool();
        ForkJoinTask<Long> task = new ForkJoinDemo(1L,10_0000_0000L);
        ForkJoinTask<Long> submit = forkJoinPool.submit(task);
        Long sum = submit.get();
        long end=System.currentTimeMillis();
        System.out.println("sum="+sum+"求和时间="+(end-start));
    }

    public static void test3(){
        long start=System.currentTimeMillis();
        long sum = LongStream.rangeClosed(0L, 10_0000_0000L).parallel().reduce(0, Long::sum);
        long end=System.currentTimeMillis();
        System.out.println("sum="+sum+"求和时间="+(end-start));
    }
}
```



## 异步回调

```java
package com.zhu.future;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;

/*
* 异步调用：CompletableFuture
* 异步执行
* 成功回调
* 失败回调
* */
public class FutureDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //没有返回值的runAsync  异步回调
        /*CompletableFuture<Void> voidCompletableFuture =
                CompletableFuture.runAsync(()->{
                    try {
                        TimeUnit.SECONDS.sleep(2);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName()+"runAsync=>Void");
                });
        System.out.println("1111");
        voidCompletableFuture.get();//获取阻塞后的执行结果*/

        //有返回值的supplyAsync  异步回调
        CompletableFuture<Integer> integerCompletableFuture =
                CompletableFuture.supplyAsync(()->{
                    System.out.println(Thread.currentThread().getName()+"supplyAsync=>Integer");
                    int i=10/0;
                    return 1024;
                });

        System.out.println(integerCompletableFuture.whenComplete((t,u)->{
            System.out.println("t=>"+t);//正常的返回结果
            System.out.println("u=>"+u);//捕获异常
        }).exceptionally((e)->{
            System.out.println(e.getMessage());
            return 233;//报错的返回结果
        }).get());
    }
}
```



## JMM

> volatile

Volatile是Java虚拟机提供的一个轻量级同步机制

1. 保证可见性
2. ==不保证原子性==
3. 禁止指令重排



> 什么是JMM

JMM：Java内存模型



关于JMM的一些同步的约定：

1. 线程解锁前，必须把共享变量立刻刷回主存。
2. 线程加锁前，必须读取主存中的最新值到工作内存中。
3. 加锁和解锁是同一把锁



线程工作内存、主内存

**8种操作：**

![image-20200620223641307](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200620223641307.png)

（1）lock(锁定)：作用于 主内存的变量，把一个变量标记为一条线程独占状态

（2）unlock(解锁)：作用于 主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定

（3）read(读取)：作用于 主内存的变量，把一个变量值从主内存传输到线程的 工作内存中，以便随后的load动作使用

（4）load(载入)：作用于 工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中

（5）use(使用)：作用于 工作内存的变量，把工作内存中的一个变量值传递给执行引擎

（6）assign(赋值)：作用于 工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量

（7）store(存储)：作用于 工作内存的变量，把工作内存中的一个变量的值传送到 主内存中，以便随后的write的操作

（8）write(写入)：作用于 工作内存的变量，它把store操作从工作内存中的一个变量的值传送到 主内存的变量中



**出现问题：**其中一个线程不知道主存中的值已经被修改了

![image-20200620224528245](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200620224528245.png)



## Volatile

> 保证可见性

```java
package com.zhu.volatiletest;

import java.util.concurrent.TimeUnit;

public class VolatileTest {
    //volatile 保证变量的可见性
    private volatile static int num=0;

    public static void main(String[] args) {
        new Thread(()->{
            while (num==0){

            }
        }).start();

        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        num=1;
        System.out.println(num);
    }
}
```



> 不保证原子性

```java
package com.zhu.volatiletest;

public class VolatileTest2 {
    //不保证原子性
    private volatile static int num=0;

    public static void add(){
        num++;
    }

    public static void main(String[] args) {
        for (int i = 1; i <= 20; i++) {
            new Thread(()->{
                for (int j = 0; j <1000; j++) {
                    add();
                }
            }).start();
        }

        while (Thread.activeCount()>2){
            Thread.yield();
        }
        System.out.println(Thread.currentThread().getName()+" "+num);
    }
}
```

**如果不加lock和synchronized，怎么保证原子性**

![image-20200620232039804](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200620232039804.png)

> 原子类Atomic

![image-20200620233040893](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200620233040893.png)

```java
package com.zhu.volatiletest;

import java.util.concurrent.atomic.AtomicInteger;

public class VolatileTest2 {
    //不保证原子性
//    private volatile static int num=0;
    private volatile static AtomicInteger num=new AtomicInteger(0);

    public static void add(){
//        num++;//不是原子性操作
        num.getAndIncrement();
    }

    public static void main(String[] args) {
        for (int i = 1; i <= 20; i++) {
            new Thread(()->{
                for (int j = 0; j <1000; j++) {
                    add();
                }
            }).start();
        }

        while (Thread.activeCount()>2){
            Thread.yield();
        }
        System.out.println(Thread.currentThread().getName()+" "+num);
    }
}
```

这些类的底层都直接和操作系统挂钩！在内存中修改值！Unsafe类是一个很特殊的类



> 指令重排

什么是指令重排：你写的程序，计算机并不是按照你写的那样去执行的

源代码--》编译器优化的重排--》指令并行也可能会重排--》内存系统也会重排--》执行

**==处理器在进行指令重排的时候，考虑：数据之间的依赖性！==**

```java
int x = 1;//1
int y = 2;//2
x = x + 5;//3
y = x * x;//4
//我们所期望的顺序：1234 |但是也可能按2134 1324顺序执行
//可不可能是   4123？==》不可能
```

可能造成影响的结果：a b x y这四个值默认都是0；

| 线程A | 线程B |
| ----- | ----- |
| x=a   | y=b   |
| b=1   | a=2   |

正常的结果：x=0，y=0但是可能由于指令重排

| 线程A | 线程B |
| ----- | ----- |
| b=1   | a=2   |
| x=a   | y=b   |

指令重排导致的诡异结果：x=2;y=1



> Volatile可以避免指令重排

内存屏障。CPU指令。作用：

1. 保证特定的操作的执行顺序
2. 可以保证某些变量的内存可见性（利用了这些特性volatile实现了可见性）

![image-20200621002333894](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200621002333894.png)

**volatile是可以保持可见性。不能保证原子性，由于内存屏障，可以避免指令重排的现象产生**



## 彻底玩转单例模式

饿汉式、DCL懒汉式

> 饿汉式

```java
package com.zhu.singleton;
//饿汉式单例
public class Hungry {
    //可能会浪费空间
    private byte[] data1=new byte[1024*1024];
    private byte[] data2=new byte[1024*1024];
    private byte[] data3=new byte[1024*1024];
    private byte[] data4=new byte[1024*1024];

    private Hungry(){

    }
    private static final Hungry hungry=new Hungry();

    public static Hungry getInstance(){
        return hungry;
    }

    public static void main(String[] args) {
        System.out.println(getInstance());
        System.out.println(getInstance());
    }
}
```

> DCL懒汉式

```java
package com.zhu.singleton;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;

public class Lazy {
    private static boolean xx=false;
    private Lazy(){
        synchronized (Lazy.class){
            if (xx==false){
                xx=true;
            }else {
                throw new RuntimeException("不要试图使用反射破坏");
            }
        }
    }

    private volatile static Lazy lazy;

    //双重检测  DCL懒汉式
    public static Lazy getInstance(){
        if (lazy==null){
            synchronized (Lazy.class){
                if (lazy==null){
                    lazy=new Lazy();//不是一个原子性操作
                    /*
                    * new的三步骤：
                    * 1、分配内存空间
                    * 2、执行构造方法，初始化对象
                    * 3、把这个对象指向这个空间
                    *
                    * 由于指令重排可能出现 123和132的顺序
                    * 当以132顺序执行时，如果有2个线程A、B
                    * 那么B线程由于lazy！=null，因此return的lazy还没有完成构造
                    * 因此需要加上volatile避免指令重排
                    * */
                }
            }
        }
        return lazy;
    }

    public static void main(String[] args) throws Exception {
        /*for (int i = 10; i > 0; i--) {
            new Thread(()->{
                getInstance();
            }).start();
        }*/

        //通过反射破坏
//        Lazy lazy=getInstance();
        Field xx = Lazy.class.getDeclaredField("xx");
        xx.setAccessible(true);

        Constructor<Lazy> declaredConstructor = Lazy.class.getDeclaredConstructor(null);
        declaredConstructor.setAccessible(true);
        Lazy lazy = declaredConstructor.newInstance();
        xx.set(lazy,false);

        Lazy lazy1 = declaredConstructor.newInstance();
        System.out.println(lazy);
        System.out.println(lazy1);
    }
}
```

> 静态内部类

```java
package com.zhu.singleton;
//静态内部类
public class Holder {
    private Holder(){

    }
    public static Holder getInstance(){
        return InnerClass.HOLDER;
    }

    public static class InnerClass{
        private static final Holder HOLDER=new Holder();
    }
}
```



> 枚举

```java
package com.zhu.singleton;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public enum  EnumSingleton {

    INSTANCE;

    public EnumSingleton getInstance(){
        return INSTANCE;
    }
}

class Test{
    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        EnumSingleton instance1 = EnumSingleton.INSTANCE;
        //NoSuchMethodException
//        Constructor<EnumSingleton> declaredConstructor = EnumSingleton.class.getDeclaredConstructor(null);

        //Cannot reflectively create enum objects
        Constructor<EnumSingleton> declaredConstructor = EnumSingleton.class.getDeclaredConstructor(String.class,int.class);
        declaredConstructor.setAccessible(true);
        EnumSingleton instance2 = declaredConstructor.newInstance();
        System.out.println(instance1);
        System.out.println(instance2);
    }
}
```

![image-20200621023958606](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200621023958606.png)



枚举类型的最终反编译：

![image-20200621024036390](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200621024036390.png)



## CAS

> 什么是CAS





> Unsafe类

![image-20200621112935654](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200621112935654.png)

![image-20200621160641395](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200621160641395.png)

CAS：比较当前工作内存中的值与主存中的值，如果这个值是期望的（相等的）那么则执行操作！如果不是就一直循环

**缺点：**

1. 循环耗时（自旋锁）
2. 一次性只能保证一个共享变量的原子性
3. ABA问题



> CAS：ABA问题

![image-20200621161340148](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200621161340148.png)

```java
package com.zhu.cas;

import java.util.concurrent.atomic.AtomicInteger;

public class CASDemo {
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(2020);
        //如果等于期望值就更新，否则就不更新；CAS是CPU的并发原语
        //捣乱的线程
        atomicInteger.compareAndSet(2020,2021);
        System.out.println(atomicInteger.get());
        atomicInteger.compareAndSet(2021,2020);
        System.out.println(atomicInteger.get());
        //期望的线程
        atomicInteger.compareAndSet(2020,6666);
        System.out.println(atomicInteger.get());
    }
}
```



## 原子引用

> 解决ABA问题，引入原子引用

带版本号原子操作==》乐观锁

```java
package com.zhu.cas;

import javax.sound.midi.Soundbank;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicStampedReference;

public class CASDemo2 {
    public static void main(String[] args) {
        //AtomicStampedReference 注意：如果泛型是包装类，注意对象的引用问题
        //正常业务操作中，泛型是用的自定义的对象
        AtomicStampedReference<Integer> atomicStampedReference = new AtomicStampedReference<>(1,1);

        new Thread(()->{
            int stamp=atomicStampedReference.getStamp();
            System.out.println("a=>"+stamp);
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            atomicStampedReference.compareAndSet(1,2,
                    atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1);

            System.out.println("a2=>"+atomicStampedReference.getStamp());

            System.out.println(atomicStampedReference.compareAndSet(2, 1,
                    atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1));

            System.out.println("a3=>"+atomicStampedReference.getStamp());

        },"a").start();

        new Thread(()->{
            int stamp=atomicStampedReference.getStamp();
            System.out.println("b1=>"+stamp);
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println(atomicStampedReference.compareAndSet(1, 6,
                    stamp, stamp + 1));
            System.out.println("b2=>"+atomicStampedReference.getStamp());
        },"b").start();
    }
}
```



## 各种锁的理解

#### 公平锁、非公平锁

公平锁：非常公平，不能插队，必须先来后到

非公平锁：非常不公平，能插队（默认都是非公平）

```java
public ReentrantLock() {
    sync = new NonfairSync();
}
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
```



#### 可重入锁

> Synchronized版

```java
package com.zhu.lock;

public class Demo01 {
    public static void main(String[] args) {
        Phone phone = new Phone();
        new Thread(()->{
            phone.sms();
        },"A").start();

        new Thread(()->{
            phone.sms();
        },"B").start();
    }
}
class Phone{
    public synchronized void sms(){
        System.out.println(Thread.currentThread().getName()+"sms");
        call();
    }
    public synchronized void call(){
        System.out.println(Thread.currentThread().getName()+"call");
    }
}
```



> Lock版

```java
package com.zhu.lock;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Demo02 {
    public static void main(String[] args) {
        Phone2 phone = new Phone2();
        new Thread(()->{
            phone.sms();
        },"A").start();

        new Thread(()->{
            phone.sms();
        },"B").start();
    }
}

class Phone2{
    Lock lock=new ReentrantLock();
    public void sms(){
        lock.lock();//Lock锁必须配对，否则会锁在里面
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName()+"sms");
            call();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
            lock.unlock();
        }
    }
    public void call(){
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName()+"call");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
```



#### 自旋锁

SpinLock

```java
package com.zhu.lock;


import java.util.concurrent.atomic.AtomicReference;

public class SpinLockDemo {
    AtomicReference<Thread> atomicReference = new AtomicReference<>();
    //加锁
    public void MyLock(){
        Thread thread=Thread.currentThread();
        System.out.println(Thread.currentThread().getName()+"==>mylock");
        //自旋锁
        while (!atomicReference.compareAndSet(null,thread)){

        }
    }
    //解锁
    public void MyUnLock(){
        Thread thread=Thread.currentThread();
        System.out.println(Thread.currentThread().getName()+"==>myunlock");
        atomicReference.compareAndSet(thread,null);
    }
}
```



```java
package com.zhu.lock;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

public class SpinLockTest {
    public static void main(String[] args) throws InterruptedException {
        /*ReentrantLock reentrantLock = new ReentrantLock();
        reentrantLock.lock();
        reentrantLock.unlock();*/

        SpinLockDemo spinLockDemo = new SpinLockDemo();
        new Thread(()->{
            spinLockDemo.MyLock();
            try {
                TimeUnit.SECONDS.sleep(5);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally {
                spinLockDemo.MyUnLock();
            }
        },"A").start();
        TimeUnit.SECONDS.sleep(1);
        new Thread(()->{
            spinLockDemo.MyLock();
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally {
                spinLockDemo.MyUnLock();
            }
        },"B").start();
    }
}
```



#### 死锁

> 死锁是什么？

