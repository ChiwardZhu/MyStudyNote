## static

#### 类的生命周期与（非）静态代码初始化时间点

我们知道类的生命周期分为装载、连接、初始化、使用和卸载的五个过程。
其中静态代码在类的**初始化阶段**被初始化。

而非静态代码则在类的**使用阶段**（也就是实例化一个类的时候）才会被初始化。

```java
class test1{
    static int x=10;
    static {
        x+=5;
    }
    public static void main(String[] args) {
        System.out.println("x="+x);
    }
    static {
        x/=3;
    }
}

//执行结果为 x=5
```

1. static修饰的方法、变量、代码块与类一同初始化
2. static执行顺序：一般被static修饰的方法最后执行，被static修饰的方法、变量顺序执行

```java
class test2{
    test2(){
        System.out.println("执行构造方法");
    }
    static {
        System.out.println("静态代码块");
    }
    {
        System.out.println("非静态代码块");
    }
    public static void main(String[] args) {
        System.out.println("执行main方法");
        test2 test2 = new test2();
    }
}
/*执行结果：
静态代码块
执行main方法
非静态代码块
执行构造方法
*/
```

1. static修饰的方法、变量、代码块与类一同加载；静态代码块先于main方法（静态方法）执行
2. 然后执行test2 test2 = new test2();即实例化一个类，才会执行非静态代码（先执行代码块，再执行构造方法）

```java
class test1{
    test1(){
        System.out.println("执行父类构造方法");
    }
    static {
        System.out.println("父类静态代码块");
    }
    {
        System.out.println("父类非静态代码块");
    }
}

class test2 extends test1{
    test2(){
        System.out.println("执行子类构造方法");
    }
    static {
        System.out.println("子类静态代码块");
    }
    {
        System.out.println("子类非静态代码块");
    }
    public static void main(String[] args) {
        System.out.println("执行main方法");
        test2 test2 = new test2();
    }
}
/*执行结果
父类静态代码块
子类静态代码块
执行main方法
父类非静态代码块
执行父类构造方法
子类非静态代码块
执行子类构造方法
*/
```

* **执行顺序：**

1. 先执行两个类的静态代码块（先执行父类的静态代码块）
2. 再执行静态方法main
3. 再执行父类的非静态代码块与构造方法
4. 最后执行子类的非静态代码块与构造方法

* **总结：**
  1. 上溯到Object类，先执行Object的静态初始化块，再向下执行子类的静态初始化块，直到类的静态初始化块被初始化为止
  2. 构造方法执行顺序和上面顺序一样



![image-20200321221711238](C:\Users\86159\AppData\Roaming\Typora\typora-user-images\image-20200321221711238.png)

## static关键字进行一个小结：

#### 1）特点：

1. static是一个修饰符，用于修饰成员（成员变量，成员方法），static修饰的成员变量称之为静态变量或类变量。
2. static修饰的成员被所有的对象共享。
3. static优先于对象存在，因为static的成员随着类的加载就已经存在。
4. static修饰的成员多了一种调用方式，可以直接被类名所调用，（类名.静态成员）。
5. static修饰的数据是共享数据，对象中的存储的是特有的数据。
6. 类变量的生命周期和类相同，在整个应用程序执行期间都有效
7. static方法不可直接访问非static的成员



#### 2）静态变量与成员变量的区别

1. 生命周期的不同：

成员变量随着对象的创建而存在随着对象的回收而释放。

静态变量随着类的加载而存在随着类的消失而消失。

2. 调用方式不同：

成员变量只能被对象调用。

静态变量可以被对象调用，也可以用类名调用。（推荐用类名调用）

3. 别名不同：

成员变量也称为实例变量。

静态变量称为类变量。

4. 数据存储位置不同：

成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据。

静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。



### 3）静态使用时需要注意的事项：

1. 静态方法只能访问静态成员。（非静态既可以访问静态，又可以访问非静态）

2. 静态方法中不可以使用this或者super关键字。

3. 主函数是静态的





## final

1. **修饰类**

   当inal去修饰一个类的时候，这个类不能被继承。

   **注意：**

   a. 被final修饰的类，final类中的成员变量可以是被final修饰也可以不用final修饰。

   b. final类中的成员方法都会被隐式的指定为final方法。

2. **修饰方法**

   被final修饰的方法不能被重写。可以重载

   **注意：**

   a. 一个类的private方法会隐式的被指定为final方法。

   b. 如果父类中有final修饰的方法，那么子类不能去重写。

3. **修饰变量为常量**

   **注意：**

   a. 必须初始化值，而且只能赋值一次。

   b. 被fianl修饰的成员变量赋值，有两种方式：1、直接赋值 2、全部在构造方法中赋初值。

   c. 如果修饰的成员变量是基本类型，则表示这个变量的值不能改变。

   d. 如果修饰的成员变量是一个引用类型，则是说这个引用的地址的值不能修改，但是这个引用所指向的对象里面的内容还是可以改变的。